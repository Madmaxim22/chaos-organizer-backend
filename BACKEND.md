# Backend-спецификация для Chaos Organizer

## Обзор проекта

Chaos Organizer — это бот-органайзер для хранения информации, поиска и сервисов, вдохновлённый функциональностью мессенджеров (Telegram, WhatsApp, Slack). Серверная часть обеспечивает хранение данных, обработку команд, синхронизацию между клиентами и реализацию бизнес-логики.

## Архитектура серверной части

### Технологический стек
- **Фреймворк:** Koa (и сопутствующие middleware)
- **Протоколы:** HTTP, WebSocket (ws), Server-Sent Events (http-event-stream)
- **Хранение данных:** В памяти процесса (массивы, `Set`, `Map`)
- **Деплой:** Render (с поддержкой постоянного хранилища)

### Особенности Render
- Render предоставляет постоянное хранилище (persistent storage), что позволяет сохранять данные между перезапусками приложения.
- Файлы, хранящиеся в определённых каталогах (например, `uploads/`), сохраняются даже после остановки и перезапуска сервиса.
- **Рекомендации:**
  - Используйте постоянное хранилище Render для хранения загруженных файлов и других данных, которые должны сохраняться.
  - Для каталогов, которые должны сохраняться, добавьте пустой файл `.gitkeep` (если они находятся в репозитории).
  - Заранее подготовьте демо-данные (хардкод), чтобы упростить тестирование и проверку.

## Ключевые функции (серверная реализация)

Все перечисленные функции являются основными и должны быть реализованы в серверной части.

### Хранение и управление данными
1. **Сохранение истории сообщений**
   - Поддержка текстовых сообщений и ссылок (`http://`, `https://`).
   - Хранение метаданных файлов (изображения, видео, аудио), загруженных через Drag & Drop или иконку загрузки.
   - Структура данных должна позволять эффективную выборку по временным меткам.

2. **Ленивая подгрузка (пагинация)**
   - API должно возвращать последние N сообщений (по умолчанию 10).
   - При запросе более старых сообщений сервер отдаёт следующие N записей.
   - Реализация через параметры `offset` и `limit`.

3. **Синхронизация между клиентами**
   - При открытии приложения в нескольких окнах/вкладках изменения должны мгновенно отражаться во всех экземплярах.
   - Использовать WebSocket или Server-Sent Events для push-уведомлений.

4. **Поиск по сообщениям**
   - Серверный полнотекстовый поиск по тексту сообщений и метаданным файлов.
   - Поддержка фильтрации по типу контента (текст, изображение, видео, аудио).

5. **Обработка команд бота**
   - Поддержка минимум 5 команд (например, `@chaos: погода`, `@chaos: помощь`, `@chaos: гороскоп`, `@chaos: анекдот` и т.п.).
   - Каждая команда возвращает заранее подготовленный ответ (интеграция с внешними сервисами не требуется).

6. **Шифрование сообщений (crypto-js)**
   - Возможность отправки зашифрованных сообщений и файлов.
   - Сервер хранит зашифрованные данные; расшифровка происходит на клиенте после ввода пароля.

### Расширенные сервисы
7. **Напоминания**
   - Установка напоминаний через команду `@schedule: 18:04 31.08.2019 «Последний день лета`.
   - Сервер отслеживает время и инициирует уведомление через Notification API (клиентская часть).

8. **Экспорт/импорт истории**
   - Генерация архива с историей чата в формате JSON/HTML.
   - Загрузка архива для восстановления истории.

9. **Офлайн-режим**
   - Сервер должен корректно обрабатывать запросы от кешированных клиентов, возвращая последние доступные данные.

10. **Архивирование файлов**
    - Использование библиотеки zip.js для упаковки нескольких файлов перед отправкой.

11. **Поддержка оформления кода**
    - Сервер должен корректно передавать блоки кода (сохранять разметку) для последующей подсветки на клиенте.

12. **Поддержка смайликов и стикеров**
    - Хранение кастомных стикеров и эмодзи в базе данных (в памяти).

## Структура данных

### Модели (в памяти)
```javascript
// Пример структуры сообщения
{
  id: uuid-v4,
  type: 'text' | 'link' | 'image' | 'video' | 'audio' | 'file',
  content: string,          // текст или URL
  timestamp: Date,
  author?: string,          // опционально, если будет поддержка пользователей
  metadata?: {
    fileName?: string,
    fileSize?: number,
    mimeType?: string,
    dimensions?: { width: number, height: number }, // для изображений/видео
    duration?: number                               // для аудио/видео
  },
  encrypted?: boolean,
  pinned?: boolean,
  favorite?: boolean
}
```

### Коллекции
- `messages: Array<Message>` – основная история.
- `pinnedMessage: Message | null` – закреплённое сообщение (только одно).
- `favorites: Set<MessageId>` – избранные сообщения.
- `reminders: Array<Reminder>` – напоминания.

## API-эндпоинты (предварительно)

| Метод | Путь | Описание |
|-------|------|----------|
| GET   | `/api/messages` | Получить последние сообщения (с пагинацией) |
| POST  | `/api/messages` | Отправить новое сообщение (текст, файл, ссылка) |
| GET   | `/api/messages/search` | Поиск по сообщениям |
| GET   | `/api/messages/:id` | Получить конкретное сообщение |
| PUT   | `/api/messages/:id/pin` | Закрепить/открепить сообщение |
| PUT   | `/api/messages/:id/favorite` | Добавить/удалить из избранного |
| GET   | `/api/attachments` | Получить вложения по категориям (аудио, видео, изображения, другие) |
| POST  | `/api/commands` | Выполнить команду бота |
| POST  | `/api/reminders` | Установить напоминание |
| GET   | `/api/export` | Экспорт истории в формате JSON |
| POST  | `/api/import` | Импорт истории из архива |

## WebSocket / SSE
- **Эндпоинт:** `/api/events`
- **События:** `new_message`, `message_updated`, `message_deleted`, `sync_required`
- Используется для реального обновления интерфейса всех клиентов.

## Конфигурация и зависимости

### package.json (пример)
```json
{
  "dependencies": {
    "koa": "^2.15.0",
    "koa-router": "^12.0.0",
    "koa-body": "^6.0.1",
    "koa-static": "^5.0.0",
    "ws": "^8.14.2",
    "http-event-stream": "^0.2.0",
    "crypto-js": "^4.1.1",
    "zip.js": "^2.7.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "eslint": "^8.56.0"
  }
}
```

### Скрипты
- `npm start` – запуск продакшн-сервера.
- `npm run dev` – запуск в режиме разработки с hot-reload.
- `npm test` – запуск тестов (если будут).

## Развёртывание
1. Репозиторий на GitHub с настроенным AppVeyor для автоматической сборки.
2. Деплой на Render через Git (или подключение репозитория через веб-интерфейс).
3. Клиентская часть размещается на GitHub Pages (отдельно или вместе с сервером).

## Примечания по реализации
- Данные хранятся только в памяти, поэтому при перезапуске сервера все данные будут потеряны. Для демо-целей это допустимо.
- Для удобства тестирования рекомендуется захардкодить начальный набор сообщений и файлов.
- Все файлы, загружаемые пользователем, должны сохраняться во временном хранилище (например, `uploads/`). На Render, благодаря постоянному хранилищу, файлы сохраняются между перезапусками, что позволяет использовать локальное хранилище для демо-версии. Для продакшена можно дополнительно использовать внешнее хранилище (например, AWS S3).

---

*Этот документ содержит только backend-спецификации. Frontend-требования описаны в файле `FRONTEND.md`.*