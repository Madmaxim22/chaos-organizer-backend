# План разработки Chaos Organizer (Backend)

На основе требований и архитектурного описания из [BACKEND.md](BACKEND.md).

## Этап 1: Настройка среды и инициализация проекта
1. **Создать репозиторий и структуру проекта**
   - Инициализировать Git-репозиторий с `.gitignore` для Node.js.
   - Создать базовую структуру каталогов: `src/`, `public/`, `uploads/` (с `.gitkeep` для сохранения пустого каталога).
   - Добавить `README.md` с описанием проекта.

2. **Установить зависимости**
   - Создать `package.json` с зависимостями, указанными в BACKEND.md (Koa, koa-router, koa-body, koa-static, ws, http-event-stream, crypto-js, zip.js).
   - Установить dev-зависимости: nodemon, eslint.
   - Настроить скрипты `start`, `dev`, `test`.

3. **Настроить базовый сервер Koa**
   - Создать точку входа `src/index.js` с минимальным HTTP-сервером.
   - Подключить middleware для обработки JSON и статических файлов.
   - Проверить запуск сервера на локальном порту.

## Этап 2: Проектирование данных и моделей
4. **Определить структуры данных в памяти**
   - Реализовать модели сообщений, напоминаний, избранного и закреплённых сообщений согласно спецификации (см. раздел «Структура данных»).
   - Создать коллекции: `messages` (массив), `pinnedMessage`, `favorites` (Set), `reminders` (массив).
   - Добавить демо-данные для тестирования (хардкод).

5. **Реализовать утилиты для работы с данными**
   - Функции для генерации уникальных ID (uuid v4).
   - Функции для фильтрации, сортировки и пагинации сообщений.
   - Вспомогательные функции для работы с метаданными файлов.

## Этап 3: Реализация основных API-эндпоинтов
6. **Маршрутизация с Koa-router**
   - Создать модуль маршрутов `/api/messages`, `/api/commands`, `/api/reminders` и т.д.
   - Реализовать обработчики для каждого эндпоинта согласно таблице API.

7. **CRUD для сообщений**
   - `GET /api/messages` – возврат последних N сообщений с поддержкой пагинации (`offset`, `limit`).
   - `POST /api/messages` – добавление нового сообщения (текст, ссылка, файл).
   - `GET /api/messages/:id` – получение конкретного сообщения.
   - `PUT /api/messages/:id/pin` – закрепление/открепление.
   - `PUT /api/messages/:id/favorite` – добавление/удаление из избранного.

8. **Поиск по сообщениям**
   - `GET /api/messages/search` – полнотекстовый поиск по тексту и метаданным.
   - Реализовать фильтрацию по типу контента (текст, изображение, видео, аудио).

9. **Управление вложениями**
   - `GET /api/attachments` – группировка вложений по категориям.
   - Логика определения MIME-типа и категории файла.

10. **Команды бота**
    - `POST /api/commands` – обработка команд вида `@chaos: ...`.
    - Реализовать минимум 5 команд с заранее подготовленными ответами.

11. **Напоминания**
    - `POST /api/reminders` – парсинг строки напоминания и сохранение в коллекцию `reminders`.
    - Фоновая проверка времени и инициирование уведомлений (через события).

12. **Экспорт/импорт истории**
    - `GET /api/export` – генерация JSON-архива всех сообщений.
    - `POST /api/import` – загрузка архива и восстановление истории.

## Этап 4: Реализация реального времени (WebSocket/SSE)
13. **Настройка WebSocket или Server-Sent Events**
    - Создать эндпоинт `/api/events` для подключения клиентов.
    - Реализовать broadcast-механизм для рассылки событий (`new_message`, `message_updated`, `message_deleted`, `sync_required`).

14. **Интеграция с API**
    - При изменении данных (добавление/обновление/удаление сообщения) отправлять событие всем подключённым клиентам.
    - Обеспечить синхронизацию между несколькими вкладками/окнами.

## Этап 5: Расширенные функции
15. **Шифрование сообщений (crypto-js)**
    - Добавить поддержку флага `encrypted` в модели сообщения.
    - Реализовать endpoint для отправки зашифрованных данных (шифрование на клиенте, хранение на сервере в зашифрованном виде).
    - Расшифровка на клиенте после ввода пароля.

16. **Архивирование файлов (zip.js)**
    - Реализовать упаковку нескольких файлов в ZIP перед отправкой клиенту.
    - Интегрировать с endpoint экспорта.

17. **Поддержка оформления кода и смайликов**
    - Обеспечить корректную передачу блоков кода (сохранение разметки).
    - Добавить коллекцию кастомных стикеров/эмодзи (хранить в памяти).

18. **Офлайн-режим**
    - Реализовать кеширование последних данных на клиенте.
    - Сервер должен корректно обрабатывать запросы от кешированных клиентов (возвращать последние доступные данные).

## Этап 6: Интеграция сторонних сервисов и инфраструктура
19. **Настройка загрузки файлов**
    - Создать временное хранилище `uploads/`.
    - Обработка multipart/form-data через koa-body.
    - Сохранение метаданных файлов в памяти.

20. **Подготовка к деплою на Render**
    - Создать `Procfile` с командой запуска.
    - Настроить переменные окружения (порт, etc).
    - Учесть особенности Render (постоянное хранилище для файлов, сохранение данных между перезапусками).

21. **Настройка CI/CD (AppVeyor)**
    - Конфигурация для автоматической сборки и тестирования.
    - Автоматический деплой на Render при пуше в main-ветку.

## Этап 7: Тестирование
22. **Модульное тестирование**
    - Написать тесты для основных функций (работа с коллекциями, пагинация, поиск).
    - Использовать Jest или Mocha.

23. **Интеграционное тестирование API**
    - Тестирование эндпоинтов с помощью Supertest.
    - Проверка корректности ответов и кодов состояния.

24. **Тестирование реального времени**
    - Проверка работы WebSocket/SSE событий.
    - Тестирование синхронизации между клиентами.

25. **Нагрузочное тестирование (опционально)**
    - Проверить производительность при большом количестве сообщений.

## Этап 8: Документация и финализация
26. **Документация API**
    - Создать OpenAPI/Swagger спецификацию или подробный Markdown-документ.
    - Описать все эндпоинты, параметры, примеры запросов/ответов.

27. **Создание демо-данных**
    - Наполнить память демо-сообщениями, файлами, напоминаниями для презентации.

28. **Финальная проверка и рефакторинг**
    - Проверка соответствия всем требованиям BACKEND.md.
    - Рефакторинг кода, улучшение читаемости, обработка ошибок.

29. **Подготовка к продакшену**
    - Настройка логгирования.
    - Добавление health-check эндпоинта.
    - Обеспечение безопасности (базовая валидация, ограничение размера файлов).

## Этап 9: Развертывание
30. **Деплой на Render**
    - Создать приложение на Render.
    - Настроить автоматический деплой из GitHub.
    - Проверить работу приложения после деплоя.

31. **Размещение клиентской части**
    - Сборка фронтенда (если отдельно) и размещение на GitHub Pages.

32. **Мониторинг и поддержка**
    - Настройка логирования ошибок (например, Sentry).
    - Планирование резервного копирования данных (если потребуется).

---

## Ссылки на разделы BACKEND.md
- **Технологический стек и особенности Render** – см. разделы «Архитектура серверной части» и «Особенности Render».
- **Ключевые функции** – см. раздел «Ключевые функции (серверная реализация)».
- **Структура данных** – см. раздел «Структура данных».
- **API-эндпоинты** – см. таблицу в разделе «API-эндпоинты (предварительно)».
- **WebSocket/SSE** – см. раздел «WebSocket / SSE».
- **Конфигурация и зависимости** – см. раздел «Конфигурация и зависимости».
- **Развёртывание** – см. раздел «Развёртывание».

---

*План составлен 07.02.2026. Актуализируется по мере развития проекта.*